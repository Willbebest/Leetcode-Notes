####  [最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

***

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**示例:**

```
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

***

**题意分析**

此题与122的差距在于，多了冷冻期。并且`prices`可以为空。

题目中定义的“冷冻期”=卖出的那一天的后一天，题目设置冷冻期的意思是，如果昨天卖出了，今天不可买入，那么关键在于哪一天卖出，只要在今天想买入的时候判断一下前一天是不是刚卖出

***

**动态规划（思路来自网络）**

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() <= 1) return 0;
        int len = prices.size();
        vector<vector<int>> dp(len, vector<int>(3));
        dp[0][0] = 0;
        dp[0][1] = prices[0];
        dp[0][2] = 0;
        for(int i = 1; i< len; i++) {
            dp[i][0] = max(dp[i-1][0], dp[i-1][2]);
            dp[i][1] = min(dp[i-1][1], prices[i] - dp[i-1][0]);
            dp[i][2] = prices[i] - dp[i][1];
        }
        return max(dp[len-1][2], dp[len-1][0]);
    }
};
```

时间复杂度O(n)，空间复杂度O(n)

因为当天卖出股票实际上也是属于“不持有”的状态，那么第i天如果不持有，那这个“不持有”就有了两种状态：

1.  本来就不持有，指不是因为当天卖出了才不持有的；

2. 第i天因为卖出了股票才变得不持有

而持有股票依旧只有一种状态。

所以对于每一天i，都有可能是三种状态：

- **不持股且当天没卖出**,定义其最大收益`dp[i][0]`
- 持股,定义其最大收益`dp[i][1]`
- 不持股且当天卖出了，定义其最大收益`dp[i][2]`

初始值，第一天的值：

- `dp[0][0]=0`;    //本来就不持有，啥也没干
- `dp[0][1] = prices[0]`;      //第0天只买入
- `dp[0][2]=0`;     //可以理解成第0天买入又卖出，那么第0天就是“不持股且当天卖出了”这个状态了，其收益为0，所以初始化为0是合理的

其它天的值，第`i`天的值：

1. 不持股

   此时只有两种情况，一种是`i-1`天原本就不持有，另一种是`i-1`原本持有但卖出了。所以：`dp[i][0]=max(dp[i-1][0],dp[i-1][2])`
   
2. 持股

    有两种情况：
    
     - 昨天我就持股，今天继承昨天的，也就是`dp[i-1][1]`
     - 昨天我不持股，今天我买入的，但前提是昨天我一定没卖！因为如果昨天我卖了，那么今天我不能交易！也就是题目中所谓“冷冻期”的含义，只有昨天是“不持股且当天没卖出”这个状态，我今天才能买入！所以是`prices[i]-dp[i-1][0]`

​         所以：`dp[i][1]=max(dp[i-1][1],dp[i-1][0]-p[i])`

3. 持股且当天卖出了，所以：`dp[i][2]=p[i]- dp[i][1]`

**优化空间**

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() <= 1) return 0;
        int len = prices.size();
        vector<vector<int>> dp(2, vector<int>(3));
        dp[0][0] = 0;
        dp[0][1] = prices[0];
        dp[0][2] = 0;
        for(int i = 1; i< len; i++) {
            dp[1][0] = max(dp[0][0], dp[0][2]);
            dp[1][1] = min(dp[0][1], prices[i] - dp[0][0]);
            dp[1][2] = prices[i] - dp[1][1];
            dp[0][0] = dp[1][0];
            dp[0][1] = dp[1][1];
            dp[0][2] = dp[1][2];
        }
        return max(dp[0][2], dp[0][0]);
    }
};
```

时间复杂度O(n)，空间复杂度O(1)

思路与上述一致